import{i7 as R,i8 as E,i9 as U,ia as W,ib as q,ic as F,fz as k,fi as I,fA as M,be as B,aN as K,h0 as Y,bf as $,aL as x,aW as Z,bj as J,hm as Q,dS as P,bS as N,id as X,ie as ee,a$ as H,ig as te,aK as ie,d5 as ae,ih as D,ay as O,ii as C,ij as re,ik as z,b0 as se,il as v,fa as ne,im as oe,c$ as le,aj as f,ak as _,am as he}from"./index-75797708.js";import{l as de}from"./LayerView3D-77681ce3.js";import{l as ce}from"./projectExtentUtils-9d38f719.js";import{g as ue}from"./ImageMaterial-9da60cfc.js";import{y as me}from"./LayerView-7059f1fc.js";import{i as ge}from"./RefreshableLayerView-710745d7.js";function pe(t,e,i){const r=R(t)/E(t),a={width:i,height:i};return r>1.0001?a.height=i/r:r<.9999&&(a.width=i*r),a.width=Math.round(a.width/(R(t)/R(e))),a.height=Math.round(a.height/(E(t)/E(e))),a}function j(t,e){return U(t,[[e[0],e[1],-1],[e[2],e[1],-1],[e[2],e[3],-1],[e[0],e[3],-1]])}function fe(t,e,i){if(!W(e,i))return j(t,i);const r=[e[1]-i[1],Math.min(e[3],i[3])-Math.max(e[1],i[1]),i[3]-e[3],123456],a=[e[0]-i[0],Math.min(e[2],i[2])-Math.max(e[0],i[0]),i[2]-e[2],123456],o=i[2]-i[0],l=i[3]-i[1],s=a[0]>0&&a[2]>0?3:2,h=r[0]>0&&r[2]>0?3:2,n=(h+1)*(s+1),c=q(3*n),u=F(2*n),d=new Array(6*(h*s-1));let S=0,b=0,G=0,g=0,p=0;for(let w=0;w<4;w++){const T=r[w];if(T<=0)continue;let A=0;for(let y=0;y<4;y++){const L=a[y];L<=0||(c[b++]=i[0]+A,c[b++]=i[1]+S,c[b++]=-1,u[G++]=A/o,u[G++]=S/l,y<3&&w<3&&(y!==1||w!==1)&&(d[p++]=g,d[p++]=g+1,d[p++]=g+s+1,d[p++]=g+1,d[p++]=g+s+2,d[p++]=g+s+1),g++,A+=L)}S+=T}const V=new Array(d.length);return new k(t,[[I.POSITION,new M(c,d,3,!0)],[I.NORMAL,new M(we,V,3,!0)],[I.UV0,new M(u,d,2,!0)]])}const we=[0,0,1];let m=class extends ge(de(me)){constructor(){super(...arguments),this.drapeSourceType=B.RasterImage,this.updatePolicy=K.SYNC,this.fullExtentInLocalViewSpatialReference=null,this.maximumDataResolution=null,this._images=new Array,this._extents=new Array,this._overlays=new Array,this.updateWhenStationary=!0,this._drapeSourceRenderer=null,this.refreshDebounced=Y(async t=>{this.destroyed||await this._doRefresh(t).catch(e=>{$(e)||x.getLogger(this).error(e)})},2e3)}get visibleAtCurrentScale(){const t=this.layer,e="effectiveScaleRange"in t?t.effectiveScaleRange:null;return Z(e,this.view.terrainScale)}initialize(){this._drapeSourceRenderer=this.view.basemapTerrain.overlayManager.registerGeometryDrapeSource(this),this.addHandles(J(()=>this.view.basemapTerrain.overlayManager.unregisterDrapeSource(this))),this.addResolvingPromise(ce(this).then(t=>this._set("fullExtentInLocalViewSpatialReference",t))),this._updatingHandles.add(()=>this.suspended,()=>this._suspendedChangeHandler())}destroy(){this.clear()}setDrapingExtent(t,e){this._spatialReference=e,t.forEach((i,r)=>{this._overlays[r]=i,this._updateImageExtent(i,r)})}_updateImageExtent(t,e){const i=this._clippedExtent(t.extent,ye);if(i==null)return;const r=pe(t.extent,i,t.resolution);let a=t.pixelRatio*this.view.state.pixelRatio;const{layer:o}=this;if("imageMaxWidth"in o&&o.imageMaxWidth!=null||"imageMaxHeight"in o&&o.imageMaxHeight!=null){const s=o.imageMaxWidth,h=o.imageMaxHeight;if(r.width>s){const n=s/r.width;r.height=Math.floor(r.height*n),r.width=s,a*=n}if(r.height>h){const n=h/r.height;r.width=Math.floor(r.width*n),r.height=h,a*=n}}const l=this._extents[e];l&&Q(l.extent,i)&&this._imageSizeEquals(i,l.imageSize,r)||(this._extents[e]={extent:P(i),imageSize:r,pixelRatio:a},this.suspended||this._fetch(e).catch(s=>{$(s)||x.getLogger(this).error(s)}))}clear(){for(let t=0;t<this._images.length;t++)this._clearImage(t)}async doRefresh(){return this._doRefresh()}async _doRefresh(t){if(this.suspended)return;const e=[];for(let i=0;i<this._extents.length;i++)this._extents[i]&&e.push(this._fetch(i,t));await Promise.allSettled(e)}async processResult(t,e,i){(e instanceof HTMLImageElement||e instanceof HTMLCanvasElement)&&(t.image=e)}findExtentInfoAt(t){for(const e of this._extents){const i=e.extent;if(new N(i[0],i[1],i[2],i[3],this._spatialReference).contains(t))return e}return null}getFetchOptions(){}async redraw(t,e){await X(this._images,async(i,r)=>{i&&(await t(i,e),await this._createStageObjects(r,i.image,e))})}_imageSizeEquals(t,e,i){if(!this.maximumDataResolution)return!1;const r=R(t)/this.maximumDataResolution.x,a=E(t)/this.maximumDataResolution.y,o=r/e.width,l=a/e.height,s=r/i.width,h=a/i.height,n=Math.abs(o-s),c=Math.abs(l-h),u=ee.TESTS_DISABLE_OPTIMIZATIONS?0:1.5;return n<=u&&c<=u}async _fetch(t,e){if(this.suspended)return;const i=this._extents[t],r=i.extent;this._images[t]||(this._images[t]={texture:null,material:null,renderGeometry:null,loadingPromise:null,loadingAbortController:null,image:null,pixelData:null,renderExtent:P(r)});const a=this._images[t];a.loadingAbortController=H(a.loadingAbortController);const o=new N(r[0],r[1],r[2],r[3],this._spatialReference);if(o.width===0||o.height===0)return void this._clearImage(t);const l=new AbortController;a.loadingAbortController=l,te(e,()=>l.abort());const s=l.signal,h=this._waitFetchReady(s).then(async()=>{const n={requestAsImageElement:!0,pixelRatio:this._overlays[t].pixelRatio,...this.getFetchOptions(),signal:s},{height:c,width:u}=i.imageSize;return this.layer.fetchImage(o,u,c,n)}).then(n=>{if(ie(s))throw x.getLogger(this).warnOnce("A call to fetchImage resolved even though the request was aborted. fetchImage should not resolve if options.signal.aborted is true."),ae();return this.processResult(a,n)}).then(()=>{D(a.renderExtent,r)});a.loadingPromise=h,await this._updatingHandles.addPromise(h.then(async()=>{O(s),await this._createStageObjects(t,a.image,s)}).catch(n=>{throw n&&!$(n)&&x.getLogger(this).error(n),n}).finally(()=>{h===a.loadingPromise&&(a.loadingPromise=null,a.loadingAbortController=null)}))}_clearImage(t){const e=this._images[t];if(e){e.renderGeometry!=null&&(this._drapeSourceRenderer.removeGeometries([e.renderGeometry],C.UPDATE),e.renderGeometry=null);const i=this.view._stage,r=e.texture;r?.unload(),i.remove(r),e.texture=null,i.remove(e.material),e.material=null,e.loadingAbortController=H(e.loadingAbortController),e.loadingPromise=null,e.image=null,e.pixelData=null}}async _createStageObjects(t,e,i){const r=this.view._stage,a=this._images[t],o=()=>{a.texture?.unload(),r.remove(a.texture),a.texture=null,a.renderGeometry&&(this._drapeSourceRenderer.removeGeometries([a.renderGeometry],C.UPDATE),a.renderGeometry=null)};if(e){const l=new re(e,{width:e.width,height:e.height,preMultiplyAlpha:!0,wrap:{s:z.CLAMP_TO_EDGE,t:z.CLAMP_TO_EDGE}});let s;if(await se(this._images[t===v.INNER?v.OUTER:v.INNER].loadingPromise),O(i),o(),await r.schedule(()=>l.load(r.renderView.renderingContext),i),r.add(l),a.texture=l,a.material==null?(a.material=new ue({transparent:!0,textureId:l.id}),r.add(a.material)):a.material.setParameters({textureId:l.id}),t===v.INNER)s=j(a.material,a.renderExtent);else{const h=this._images[0].renderExtent;if(!h)return void o();s=fe(a.material,h,a.renderExtent)}a.renderGeometry=new ne(s),a.renderGeometry.localOrigin=this._overlays[t].renderLocalOrigin,this._drapeSourceRenderer.addGeometries([a.renderGeometry],C.UPDATE)}else o(),r.remove(a.material),a.material=null}_clippedExtent(t,e){if(this.view.viewingMode!=="local")return D(e,t);const i=this.view.basemapTerrain;return i.ready?oe(t,i.extent,e):D(e,t)}_suspendedChangeHandler(){this.suspended?this.clear():this.refreshDebounced()}async _waitFetchReady(t){await le(()=>this.view.stationary,t),O(t)}};f([_()],m.prototype,"layer",void 0),f([_()],m.prototype,"suspended",void 0),f([_({readOnly:!0})],m.prototype,"fullExtentInLocalViewSpatialReference",void 0),f([_({readOnly:!0})],m.prototype,"visibleAtCurrentScale",null),f([_()],m.prototype,"updating",void 0),m=f([he("esri.views.3d.layers.DynamicLayerView3D")],m);const be=m,ye=P();export{be as N};
