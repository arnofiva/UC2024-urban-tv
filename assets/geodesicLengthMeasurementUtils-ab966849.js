import{nc as v,dX as J,bT as ft,gR as K,nd as pt,at as T,ce as st,bQ as dt,al as Mt,ne as gt,nf as mt,fC as $t,eo as U,eQ as yt,e5 as Rt,l8 as wt,eP as vt,ng as zt,l9 as at,cV as bt,nh as Z}from"./index-cc5260cc.js";import{geodesicLength as rt}from"./geometryEngine-e72ad282.js";function it(t){if(!t)return null;if(K(t)&&t.wkid){const n=pt[t.wkid];if(n)return n}const e=t.wkt2||t.wkt;if(e){const n=jt(e);if(n)return n}return null}function jt(t){const e=gt.exec(t);if(!e||e.length!==2)return null;const n=e[1].split(",");if(!n||n.length<3)return null;const s=parseFloat(n[1]),a=parseFloat(n[2]);return isNaN(s)||isNaN(a)?null:{a:s,f:a===0?0:1/a}}function H(t){const e=it(t);if(qt(e))return e;const n=e.a*(1-e.f);return Object.assign(e,{b:n,eSq:1-(n/e.a)**2,radius:(2*e.a+n)/3,densificationRatio:1e4/((2*e.a+n)/3)})}function qt(t){return t!=null&&"b"in t&&"eSq"in t&&"radius"in t}function I(t,e,n){const{a:s,eSq:a}=H(n),r=Math.sqrt(a),c=Math.sin(e[1]*v),i=s*e[0]*v;let l;return a>0?l=s*((1-a)*(c/(1-a*(c*c))-1/(2*r)*Math.log((1-r*c)/(1+r*c))))*.5:l=s*c,t[0]=i,t[1]=l,t}function F(t){return it(t)!==null}function Ot(t,e="square-meters"){if(t.some(c=>!F(c.spatialReference)))throw new T("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let c=0;c<t.length;c++){const i=t[c],l=i.spatialReference,{radius:u,densificationRatio:h}=H(l),o=u*h;n.push(xt(i,o))}const s=[],a=[0,0],r=[0,0];for(let c=0;c<n.length;c++){const{rings:i,spatialReference:l}=n[c];let u=0;for(let h=0;h<i.length;h++){const o=i[h];I(a,o[0],l),I(r,o[o.length-1],l);let d=r[0]*a[1]-a[0]*r[1];for(let M=0;M<o.length-1;M++)I(a,o[M+1],l),I(r,o[M],l),d+=r[0]*a[1]-a[0]*r[1];u+=d}u=st(u,"square-meters",e),s.push(u/-2)}return s}function St(t,e="meters"){if(!t)throw new T("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(t.some(s=>!F(s.spatialReference)))throw new T("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let s=0;s<t.length;s++){const a=t[s],{spatialReference:r}=a,c=a.type==="polyline"?a.paths:a.rings;let i=0;for(let l=0;l<c.length;l++){const u=c[l];let h=0;for(let o=1;o<u.length;o++){const d=u[o-1][0],M=u[o][0],y=u[o-1][1],g=u[o][1];if(y!==g||d!==M){const p=new Y;_(p,[d,y],[M,g],r),h+=p.distance}}i+=h}i=st(i,"meters",e),n.push(i)}return n}function xt(t,e){if(t.type!=="polyline"&&t.type!=="polygon")throw new T("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");const{spatialReference:n}=t;if(!F(n))throw new T("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");const s=t.type==="polyline"?t.paths:t.rings,a=[],r=[0,0],c=new Y;for(const i of s){const l=[];a.push(l),l.push([i[0][0],i[0][1]]);let u,h,o=i[0][0],d=i[0][1];for(let M=0;M<i.length-1;M++){if(u=i[M+1][0],h=i[M+1][1],o===u&&d===h)continue;const y=[o,d];_(c,[o,d],[u,h],n);const{azimuth:g,distance:p}=c,R=p/e;if(R>1){for(let m=1;m<=R-1;m++)X(r,y,g,m*e,n),l.push(r.slice(0));X(r,y,g,(p+Math.floor(R-1)*e)/2,n),l.push(r.slice(0))}X(r,y,g,p,n),l.push(r.slice(0)),o=r[0],d=r[1]}}return t.type==="polyline"?new dt({paths:a,spatialReference:n}):new Mt({rings:a,spatialReference:n})}class Y{constructor(e=0,n=void 0,s=void 0){this.distance=e,this.azimuth=n,this.reverseAzimuth=s}}function X(t,e,n,s,a){const r=e[0],c=e[1],i=r*v,l=c*v,u=(n??0)*v,{a:h,b:o,f:d}=H(a),M=Math.sin(u),y=Math.cos(u),g=(1-d)*Math.tan(l),p=1/Math.sqrt(1+g*g),R=g*p,m=Math.atan2(g,y),C=p*M,x=C*C,z=1-x,f=z*(h*h-o*o)/(o*o),A=1+f/16384*(4096+f*(f*(320-175*f)-768)),N=f/1024*(256+f*(f*(74-47*f)-128));let w,j,$,k,S=s/(o*A),b=2*Math.PI;for(;Math.abs(S-b)>1e-12;)$=Math.cos(2*m+S),w=Math.sin(S),j=Math.cos(S),k=N*w*($+N/4*(j*(2*$*$-1)-N/6*$*(4*w*w-3)*(4*$*$-3))),b=S,S=s/(o*A)+k;const q=R*w-p*j*y,G=Math.atan2(R*j+p*w*y,(1-d)*Math.sqrt(x+q*q)),L=Math.atan2(w*M,p*j-R*w*y),P=d/16*z*(4+d*(4-3*z)),V=G/v,W=(i+(L-(1-P)*d*C*(S+P*w*($+P*j*(2*$*$-1)))))/v;return t[0]=W,t[1]=V,t}function _(t,e,n,s){const a=e[0]*v,r=e[1]*v,c=n[0]*v,i=n[1]*v,{a:l,b:u,f:h,radius:o}=H(s),d=c-a,M=Math.atan((1-h)*Math.tan(r)),y=Math.atan((1-h)*Math.tan(i)),g=Math.sin(M),p=Math.cos(M),R=Math.sin(y),m=Math.cos(y);let C,x,z,f,A,N,w,j,$,k,S=1e3,b=d;do{if(w=Math.sin(b),j=Math.cos(b),z=Math.sqrt(m*w*(m*w)+(p*R-g*m*j)*(p*R-g*m*j)),z===0)return t.distance=0,t.azimuth=void 0,t.reverseAzimuth=void 0,t;A=g*R+p*m*j,N=Math.atan2(z,A),$=p*m*w/z,x=1-$*$,f=A-2*g*R/x,isNaN(f)&&(f=0),k=h/16*x*(4+h*(4-3*x)),C=b,b=d+(1-k)*h*$*(N+k*z*(f+k*A*(2*f*f-1)))}while(Math.abs(b-C)>1e-12&&--S>0);if(S===0){const W=o,ct=Math.acos(Math.sin(r)*Math.sin(i)+Math.cos(r)*Math.cos(i)*Math.cos(c-a))*W,tt=c-a,lt=Math.sin(tt)*Math.cos(i),ut=Math.cos(r)*Math.sin(i)-Math.sin(r)*Math.cos(i)*Math.cos(tt),ht=Math.atan2(lt,ut);return t.azimuth=ht/v,t.distance=ct,t.reverseAzimuth=void 0,t}const q=x*(l*l-u*u)/(u*u),G=q/1024*(256+q*(q*(74-47*q)-128)),L=u*(1+q/16384*(4096+q*(q*(320-175*q)-768)))*(N-G*z*(f+G/4*(A*(2*f*f-1)-G/6*f*(4*z*z-3)*(4*f*f-3)))),P=Math.atan2(m*Math.sin(b),p*R-g*m*Math.cos(b)),V=Math.atan2(p*Math.sin(b),p*R*Math.cos(b)-g*m);return t.azimuth=P/v,t.distance=L,t.reverseAzimuth=V/v,t}function Qt(t){return F(t)?t:J(t)?ft.WGS84:null}function Ut(t,e,n,s){n.projectToRenderScreen(t,et),n.projectToRenderScreen(e,nt),Rt(s,nt,et),wt(s,s)}function At(t,e,n,s,a=U()){const r=vt(D,t);return r[2]=zt(s,r,e,n)||0,s.renderCoordsHelper.toRenderCoords(r,e,a),a}function Zt(t,e,n,s){return s.type==="2d"?(E.x=t[0],E.y=t[1],E.spatialReference=e,s.toScreen(E)):(At(t,e,n,s,D),s.state.camera.projectToScreen(D,B),mt(B[0],B[1]))}const E=$t(0,0,0,null),D=U(),et=at(),nt=at(),B=yt();function Ht(t){return K(t)&&F(t)||J(t)}function ot(t,e,n,...s){return K(t)&&F(t)?e.apply(void 0,s):J(t)?n.apply(void 0,s):null}const Lt=1e5;function Vt(t){const{spatialReference:e}=t;return ot(e,Ft,Gt,t)}function Wt(t,e){if(!bt(t.spatialReference,e.spatialReference))return null;const{spatialReference:n}=t;return O[0]=t.x,O[1]=t.y,O[2]=t.hasZ?t.z:0,Q[0]=e.x,Q[1]=e.y,Q[2]=e.hasZ?e.z:0,Nt(O,Q,n)}function Nt(t,e,n){return ot(n,kt,Ct,t,e,n)}function kt(t,e,n){return Z(_(Tt,t,e,n).distance,"meters")}function Ct(t,e,n){return Z(rt(Pt(t,e,n),"meters"),"meters")}function Ft(t){return Z(St([t],"meters")[0],"meters")}function Gt(t){return Z(rt(t,"meters"),"meters")}function Pt(t,e,n){return{type:"polyline",spatialReference:n,paths:[[[...t],[...e]]]}}const Tt=new Y,O=U(),Q=U();export{Qt as A,Ut as a,X as b,Zt as d,Wt as f,Lt as i,_ as j,At as l,Vt as m,ot as p,Ht as r,Nt as u,Ot as y,Y as z};
